<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>论文翻译</title>

  <link href="../igoist.github.io/static/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>
<body>


  <header id="header">
    <h1>通过移动电话中的相机设备实现条码辨识器</h1>
  </header>

  <section id="content">
    <h2>摘要</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇论文解释了有关应用于移动电话的条形／二维码图像识别的新型算法与实现。在本文所讲到的移动电话系统中，包括了内置相机、移动应用处理器、数字信号处理器（下文都将使用 DSP 代替）、显示器这几个基本组成要素，此外，后面需要被用来辨识的原图像会由内置相机来捕获。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即将在本文中介绍的算法是＃基于＃通过内置 DSP，使用四角检测二维条码或是使用螺旋扫描一维条码所找到所需要的代码区。这个算法在实际情景中足够健壮，＃现代的 DSP 有＃足够的性能来完成代码的实时识别。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的图像处理在性能方面，对于条形码是 66.7 帧每秒，对于二维码图像处理是 14.1 帧每秒，并且在实际使用当中这样的性能完全能够满足我们的需求。已发布的移动电话在＃图像处理方面的性能＃是 5 - 10 帧每秒，这包括了操作系统与子系统的性能开销。</p>
    <br />
    <p>关键字： 图像处理， 条形码， 移动电话， 数字信号处理器 DSP (Digital Signal Processor)</p>
    <br />

    <h2>第一部分：介绍</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的移动电话已经实现了各种新型的应用，就像可以用内置相机拍照片、拍电影，当然这种进步也得益于相机设备技术的发展。举例来讲，在 2003 年的时候，全日本的移动电话当中已经有 30％ 内置了相机，并且那之中有一部分是超过百万像素级别的图像传感器相机。同样，内置相机可以用作诸如符号识别的新型输入接口。在日本，大多数内置了相机的移动电话支持符号识别，就如能识别一维的条形码以及二维码，这些代码符号可便于通过读取 URL 地址或是类似的地址字符来使用电话提供的网络服务。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前的工作演示了用到特殊标签的应用，其标签是由 PC 机的内置摄像头捕获，并通过 PC 机上的软件来识别。在这次的应用中，我们要用到特殊的二维码以及标准的 PC 机。在一份关于识别一维条码的研究中，讲述了如何运用霍夫变换在 PC 机上实现一维条码读取器。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一方面，移动电话的系统架构已经被半导体供应商改变。时下或最新一代的电话设备只有一个被称为基带处理器的主处理单元，但是其计算能力对于组合了音频和视频数据的新应用来说是不够的。应用程序革命为此在更新一代移动电话中加入了一个名为应用处理器的额外处理器。在这个背景下，时下的高端移动电话中会包含这两个处理器：其一是基带处理器，它适用于语音数字信号处理，协议控制，电源管理，和一些基本的功能；另一个是应用处理器，负责处理额外的应用，如电影编解码器，照片编解码器和调整大小，以及其他额外的应用。尤其是应用处理器，目前它的性能好坏决定了移动电话的特性。市面上大部分应用处理器是由德州仪器生产的 OMAP，以及瑞萨生产的 SH-Mobile。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们为条形码和二维条码引入了一个新的图像重组算法，这是在我们的应用平台中实现的，内容详见本文第 3 节。该算法是为当前这种内置有相机、应用处理器、DSP的移动电话架构所开发的。该算法使用螺旋扫描方法来检测一维条形码的关键黑条，使用四角检测找到二维码的代码区。在这份研究中，图像处理部分由 DSP 来实现，而解码、用户软件部分则在应用处理器的主机 CPU 中实现。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;硬件系统和处理流程会在第 2 节中讲到。关于一维/二维条码符号的图像识别算法则会在第 3 节中被讨论，此外其实现与性能评估会在第 4 节中给出说明，而第 5 节则给出了实际测试结果。</p>
    <br />

    <h2>第二部分：系统</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节介绍在移动电话中实现条形码读取系统的硬件系统架构及其处理流程。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相机设备和应用处理器是该系统的必要硬件组件。其中，应用处理器需要实现相机接口、LCD 控制器、图像处理用的 DSP，以及实时计算用的应用程序主 CPU（如图 1 所示）。应用处理器用于显示菜单中的显示和预览以及实时码识别与译码的计算。这样的系统使用户可以控制相机的位置，并决定捕捉时机。处理流程如下：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 执行条码辨识应用程序 －－ 应用处理器通过用户在菜单选择，进入条码辨识模式。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 从内置相机设备捕获 －－ 源图像通过相机接口被内置相机设备捕获，并将这些图像发送到两个单元，DSP，LCD 控制器，分别用于进行图像处理和播放用户预览。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 在 DSP 中处理图像 －－ 捕获到源图像后，条码信息是在 DSP 中进行检测与处理，并且在这个阶段，处理后的图像将作为标准大小和二值化图像的编码区输出。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 解码 －－ 前一阶段中处理的条码数据是在主机 CPU 中被解码的，并且解码后的条码信息会导出到应用程序。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 显示结果 －－ 主应用程序显示解码后的结果。</p>
    <div class="i-wrap"><img src="./img/01.png" style="width: 584px;height: 468px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文将主要介绍 DSP 中的条码识别算法，并且下文中对于实现与性能方面的讨论，我们的评估都是基于该系统，因为我们相信，对移动电话系统的理解在实际应用中非常重要。</p>
    <br />

    <h2>第三部分：算法</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一维条形码与二维码的图像处理过程在这节中提出，并且这两种码在日本移动市场中是被公认的事实标准。本文不讨论解码过程的代码，因为解码过程符合 ISO / IEC 标准规范，并已在我们系统的主机 CPU 中实现。这些算法的输入和输出定义如下：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 输入数据 －－ 移动电话内置相机捕获的图像，它必须由 YUV 色彩分量组成。这个图像可能会带有很多噪音，模糊，光线不均匀，以及附近的字符。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 输出数据 －－ 一维条形码在条码部分的一维样本扫描结果（8位灰度线段）以及二维码二维归一化双层数据（1 个单元格相当于 1 比特）</p>

    <h3>3.1 一维条形码</h3>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一维条形码有四种宽度类型的黑色或白色条纹，且这些条纹的排列方向总是相互平行的。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本算法中，这些平行的黑条纹用来识别条形码的区域，我们假定图片的中心包含代码区域的一部分，因为这样的话能大大减小搜索条码所在区域的计算成本。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法包括以下阶段（如图 2 所示）：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 预处理 －－ 通过内置相机获得的图像会在这个阶段中经过预处理，用来定义黑与白强度水平边界的阈值，并且所获得的图像的颜色空间是由 YUV 分量组成，因此，我们可以选择 Y 分量来进行图像处理。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 黑条纹检测 －－ 预处理的图像被使用螺旋搜索方法进行扫描，该方法从图像中心扫描螺旋，直到找到一竖黑色条纹。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 采样 －－ 垂直于黑条纹的线是用上一阶段检测到的黑条来计算的，且整个条纹图案是根据计算所得的方向采样出来。</p>
    <div class="i-wrap"><img src="./img/02.png" style="width: 573px;height: 322px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解码器程序的结果不是一个双级图像，而是一个 8 位灰度原始数据，因为黑白条纹各有四种宽度类型，需要解码结果来决定线段的每一部分的更好的阈值。值得一提的是，一般情况下在条形码底部都写会有一些字符，但在我们的算法中，通过用螺旋扫描方法获得采样线中黑色条纹的行高，就可以排除这部分，并且这些行高决定了条码区域的顶部和底部边界。同样，从我们的实验结果来看，看条形码时候的距离与失焦问题可以忽略。</p>

    <h3>3.2 二维码</h3>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，主要要讲二维码图像的识别与处理过程。由 DENSO3 开发的 QR 码，被普遍认为是一种二维的条码。这种二维码的特点是容量大，打印输出小，扫描速度快。</p>
    <div class="i-wrap"><img src="./img/03.png" style="width: 560px;height: 332px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图 3 所示表明了二维码的结构，此码由以下几部分组成：查找模式、时序模式、格式信息、对齐模式和数据单元。它的定义可详见于本文底部引用：[2]。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用中有介绍识别过程的实例，它基于上述的查找模式、对齐模式，其中此对齐模式用于调整二维码变形。然而，要使用这种对齐标记的变形误差校正，代码读取过程中需要找到对齐标记。在我们的系统中，图像识别和解码部分被分离，以便实时识别移动电话平台上的二维码，并能应用到其他二维的码符号。基于上述原因，我们制定了新的识别方案。</p>
    <div class="i-wrap"><img src="./img/04.png" style="width: 800px;height: 211px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法的概述如下所示（见图4）：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 预处理 －－ 灰度直方图计算的方式被采用。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 角标志检测 －－ 使用取景器模式检测三个标记的角。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 断定第四个角 －－ 用特定算法检测出第四个角。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 逆透视变换 －－ 采用逆变换是基于获得的角点几何位置规范代码的大小。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 二维码扫描 －－ 采样二维码内容并将标准化的双级代码数据输出到主机 CPU。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述方案可以适用于其他类型的代码，因为该方案只使用了 QR 码的一个关键模式：用取景器模式来检测正方形区域。算法的细节会在下一小节中讲述。</p>

    <h3>3.2.1 预处理</h3>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从相机接口获得的输入图像具有 YUV 颜色空间的分量（亮度和色度），我们使用其中有8位（256级）灰度数据的 Y 分量，为该图像进行处理。进行预处理，要用到以下三个图像处理的步骤：1. 直方图计算以确定黑白边界阈值；2. 调整原图像的大小，以降低下一阶段的计算成本 —— 识别 QR 码所在区域；3. 区域扩张滤波。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在直方图计算这一步骤中，对 60 × 60 正方形区域的图像中心附近的九个部分作为采样点，来定义黑白亮度转换双水平图像之间的阈值。为每个选定区域的像素密度进行排序，并将排序密度（中值亮度）的中值作为该区域的阈值。这之后，根据实验结果，阈值被定义为所有选定的区域的阈值中的最小值。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义好阈值之后，调整过的图像要再次延 x、y 轴方向缩小一半，用作原始亮度分量的图像，以减少计算量。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，过滤，以填充孔（区域扩张），用于识别 QR 码区。以原始的四个像素作为最小密度，并转换为一个像素，而在我们的实现中，过滤这一步骤也与原图像大小调整的过程相结合。</p>

    <h3>3.2.2 码区检测</h3>
    <div class="i-wrap"><img src="./img/05.png" style="width: 580px;height: 286px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过滤、缩放后的图像用于发现粗糙码区，这些过程都有在下面的列表中显示。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 计算如图 5 中所示的重心位置（Xc，Yc）在，我们假设它为捕获的图像的中心。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 从外到内八个方向来扫描线，直到线触及该码区。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 如果一行上有两个或两个以上的像素（如图 5 右侧所示），便意味着得到了它们的边缘点。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 向 8 个方向扫描之后，我们最多能获得 16 个边缘点。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 离 (0，0) 最近的点是众多目标之一。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 定义矢量 P 为 (X0，Y0) - (Xc，Yc)。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7. 计算内积寻找其他边缘点。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过上述过程后，边缘在原图像中的位置经过如下步骤细化：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 设置一条从点 (X0，Y0) 到 (Xc，Yc) 的直线。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 交点位于标记的外边缘。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 从交点开始递归区域生长。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4. 得到外标记的重心，这是内标。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5. 从内标位置重新开始递归区域生长。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6. 标记中心被定义为内标记的重心。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7. 边缘点被定义为离图像中心最远的点。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程使用查找模式能获得三个边缘点，但是第四个边缘点没有相应的获取模式，正因为第四个角落不存在对应的单元格。由于 QR 码的这些特征，我们要介绍一种新的角落点检测算法，用于识别第四个角落点。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 使已知的几个角落点相互连线，以大致得到第四个角落点的位置（如图 6 所示）。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 移动交点，以便通过触摸码区域（线段连接方法）显示线段。</p>
    <div class="i-wrap"><img src="./img/06.png" style="width: 550px;height: 246px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上述过程计算出的码大小和识别码的功能可以用于码规格的验证，像码的大小（码大小总是奇数），同样还有宽、高，以及解码前对齐标记的位置（如图 7 所示）。</p>
    <div class="i-wrap"><img src="./img/07.png" style="width: 580px;height: 372px;"></div>

    <h3>3.2.3 逆透视变换</h3>
    <div class="i-wrap"><img src="./img/08.png" style="width: 588px;height: 322px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入图像由于是由内置相机设备捕获，图形有可能会发生一定程度的畸变。举例来说，就如图 8 中所示，而我们可以使用反向透视变换来规范码的形状。其方程如下所示：</p>
    <div class="i-wrap"><img src="./img/x1.png" style="width: 400px;height: 74px;"><img src="./img/x2.png" style="width: 400px;height: 74px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中 u、v 是发生畸变了的原图像中的坐标，而 x、y 则是恢复后的坐标。上式中的系数 c0 ∼ c7 可以由上面四对点获得（如图 9 所示）：</p>
    <div class="i-wrap"><img src="./img/09.png" style="width: 536px;height: 240px;"></div>

    <h3>3.2.4 二维码扫描</h3>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般的 QR 码识别方法（规范者提到的方法）是使用时序模式和对齐模式来扫描码。但是我们的算法是基于四个角落点，于是每个单元格中的码符号可以直接使用逆透视变换来扫描。在我们的算法中，计算的成本取决于码的大小，而不是图像的大小，这对于处理大尺寸的输入图像是很有利的。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，被扫描的图像会作为归一化的双级图像输出到主机应用程序。</p>

    <h3>3.3 局限性</h3>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们算法的性能非常地依赖于符号位于角落位置的精确程度，而在黑色和白色部分之间的边界处的阈值将产生 1 - 3 像素的偏差，这在实践研究中，在边缘点，有时会导致错误识别。当然，我们可以采取一些阈值重试的办法来减小这个问题所带来的性能影响。另一方面，如果取得好的阈值，即便图像有写模糊，我们的算法也总能直接基于变换方程有效地扫描码（在扫描单元格的时候，我们的算法总是将一个单元格作为一个像素目录来扫描）。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际的实现中，阈值的改变得通过主应用程序来调整相机的曝光值（EV）。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该算法假定输入图像是歪斜的码符号，但不能所有边缘都是弯曲的。然而，该算法被应用于使用递归近似的方法来处理弯曲的码符号，如图 10 中所示。控制点通过基于找到边缘点后进行搜索后被添加。单元格的位置，可以基于这些边缘点由相同的变换方案计算出来。</p>
    <div class="i-wrap"><img src="./img/10.png" style="width: 600px;height: 242px;"></div>

    <h2>第四部分：实现</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此应用程序实现于我们所举例的硬件架构中，该硬件架构具有如下规格：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 主 CPU：V850（@ 60MHz），它可以直接访问外部同步动态随机存储器（SDRAM）。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. DSP SPXK4：核心（@ 100MHz）具有嵌入式存储器，64k 字节指令，和两套 32k 字节 x 和 y 数据存储器。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 外设：相机接口，LCD控制器，包括窗口合成硬件等。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是每个阶段的算法实现：</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 输入图像：利用硬件调整大小，并进行过滤。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 码区域与第四角落位置估计：实现于 DSP 中。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 逆透视变换：原来的浮点库是为了与这阶段所开发的，因为这里的 DSP 本身没有实现浮点数计算单元。这个浮点格式如下：2 的负 16 次方至 2 的 8 次方。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图像处理过程的代码是由完整的汇编代码所写就，并能实时相应，而 DSP 只使用本地存储器进行计算。源数据是由静态RAM（SRAM）控制器来准备，而数据则会在 DSP 的处理过程中被并行转换字。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表 1 显示了图像处理部分的内存和指令代码大小，而这表明了在移动电话平台上，DSP 实现能仅以微量的代码来执行处理过程。图像源被存储在主存储器中，而暂存器则被用作临时存放 DSP 的计算结果。</p>
    <div class="i-wrap"><img src="./img/t1.png" style="width: 580px;height: 260px;"></div>

    <h2>第五部分：实验的结果</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这一节中，会基于前面的实现讲讲实验结果与其性能。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图 11 展示了处理条形、二维码的核心性能以及各种状态下最大指令循环数。根据以下条件，我们的算法能够达到每秒处理 66.7 帧一维码识别或每秒处理 14.1 帧二维码这样的性能。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. DSP: μ PD77210 (时钟频率: 100MHz)。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 输入图像： QVGA (320 x 240)。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3. 输出数据格式（最大）：版本 13 的一维条码解码为 320 像素的灰度图像；版本 10 的二维码解码为 57 x 57 像素的二进制图像。</p>
    <div class="i-wrap"><img src="./img/11.png" style="width: 600px;height: 491px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图 12 举例了一些应用了我们算法的实验结果，同时显示了多种情况，如阴极射线管显示器上的图像以及贴在金属罐上的标签。对于这些一般场景，该算法是合适的，没有性能降低 —— 即便它是实现于移动电话平台上。</p>
    <div class="i-wrap"><img src="./img/12.png" style="width: 800px;height: 520px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在不同的环境条件下计算时间的实际结果如图 13 所示。这些点绘制了根据两种位于室内不同地方和光照条件下的处理性能在处理图像后的错误率，这表明识别率非常地依赖于环境，尤其是光照条件，十分影响黑白边界的识别。此外，这个结果表明，错误率的大小和其图像处理性能无关。这种特性在一般的使用中非常重要，因为性能下降可能是由于手抖动导致被捕获图像变得模糊。</p>
    <div class="i-wrap"><img src="./img/13.png" style="width: 600px;height: 521px;"></div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这个核心，在移动电话上的码识别功能，可以实现每秒识别 5 - 10 帧，包括系统开销，如操作系统本身和设备子系统。</p>

    <h2>第六部分：结论</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一维码与二维码识别对于新算法在实际使用中的健壮性以及代码量的大小有所要求，而这在我们的移动应用处理器架构中已经实现，该架构中包含内置主机 CPU，DSP，相机接口和 LCD 控制器。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的算法中，被介绍的算法是基于使用内置 DSP 四角检测找到二维码码区或螺旋扫描的方法找到条形码码区。其计算开销适用于目前的移动应用程序，并且在实际情境中，这种方法是健壮的。</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其结果是，实际测试表明，该算法可以采用，它在使用环境中的性能可达每秒钟处理 66.7 帧一维码或每秒钟处理 14.1 帧二维码图像，足够实际的使用。该算法可以应用于其他二维条码的识别任务，发展任何二维条码的组合算法，这些是在未来所要做的。同样，作为未来的主要工作，靠阈值决定的方法会基于相机设备模型的建模来开发。</p>

    <h2>鸣谢</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们得感谢所有我们实验室的成员与开发团队所提供的大量建议与大力支持。</p>

    <h2>引用</h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1] ISO/IEC 15420:2000. Information technology – Automatic identification and data capture techniques – Bar code symbology specification – EAN/UPC, 2000.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[2] ISO/IEC 18004:2000. Information technology – Automatic identification and data capture techniques – Bar code symbology – QR Code, 2000.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3] H. Kurosaka, K. Miyamoto, Y. Nagase, H. Ikegami, K. Sato, and M. Otsubo. Mo- bile Phone Application LSI Design Using C based Design Methodology. Tech-nical Report 4, NEC Corporation, 4 2003.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[4] J. Matas, L. Soh, and J. Kittler. Object recognition using a tag. In 1997 International Conference on Image Processing (ICIP ’97) 3-Volume Set-Volume 1, pages 877–880. IEEE, IEEE Computer Society Press, 10 1997.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[5] R. Muniz, L. Junco, and A. Otero. A Robust Software Barcode Reader Using the Hough Transform. In Proc. of 1999 International Conference on Information Intelligence and Systems, pages 313–319. IEEE, IEEE Computer Society Press, 1999.</p>
    <!-- <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> -->

    <!-- <div class="i-wrap"><img src="./img/03.png" style="width: 573px;height: 322px;"></div> -->
  </section>

</body>
</html>